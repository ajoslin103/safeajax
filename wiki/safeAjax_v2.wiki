#labels ajoslin,ajax,security,jquery,plugin,php,password,session,cookie
General information about the safeAjax plugin by Allen Joslin

=== In Summary ===

Ajax is a thing of beauty, combining Ajax and jQuery creates elegance -- elegance with a need for quality protection, protection that is offered via safeAjax.

I wrote this plugin to password protect web pages/sites and also to safeguard my backend resources and actions. It's originally based upon Chris Shifletts article: the truth about sessions, and uses the cross-platform JSON notation for communications between the javascript and the server-side code.  

=== Web-side Usage === 

At this time there are several plugins that safeAjax depends upon, the next version will load them automatically -- for now you have to include them yourself 

{{{
<script type='text/javascript'     src='http://code.jquery.com/jquery-latest.pack.js'></script>
<script type='text/javascript'     src='http://www.json.org/json2.js'></script>
<link type='text/css' media='all' href='http://dev.iceburg.net/jquery/jqModal/jqModal.css' rel='stylesheet' />
<script type='text/javascript'     src='http://dev.iceburg.net/jquery/jqModal/jqModal.js'></script>
<script type='text/javascript'     src='http://plugins.jquery.com/files/jquery.sha1.js.txt'></script>
<script type='text/javascript'     src='http://plugins.jquery.com/files/jquery.query-2.1.5.js.txt'></script>
}}}

Now add a safeAjax div anywhere in your document, note that safeAjax uses console logging for errors and progress info

{{{
	<div id='safeAjax'></div>
}}}

Then include safeAjax and identify the connector

{{{
<script type='text/javascript'      src='./lib/safeAjax/jquery.safeAjax_v2.js'></script>
<script type='text/javascript'>
$(document).ready(function() {
   $('#safeAjax').safeAjax({ ajaxConnector: './lib/safeAjax/dbConnector.php' });
});
</script>
}}}

Use the connector at will to request info and actions from the backend, should your backend decide a resource/action needs protection then safeAjax will enforce it automatically

The LightBox plugin will be used to present a login dialog which will not go away until the backend accepts the given username and password combination and cookies the user's browser (the cookie does not contain any info that can be used to authorize any other browser or session and has a configurable expiry date.)

Once the user succeeds then the request will be re-submitted and approved using the previously deposited cookie.  The request/response that causes the login to be required is discarded and automatically re-submitted by safeAjax to streamline the process of approving requests as well as improving the overall security.

{{{

// for our purposes, the backend allows this
$('#safeAjax').safeDBMS({ load: 'address', id: addrId },function(data){ 
   $('#addr').val(data.addr);    $('#city').val(data.city);
   $('#state').val(data.state);  $('#zip').val(data.zip);
});

// for our purposes, the backend restricts this
$('#saveBtn').click(function(){
   dataItems = { save: 'address', id: addrId };
   dataItems.addr = $('#addr').val();    dataItems.city = $('#city').val();
   dataItems.state = $('#state').val();  dataItems.zip =$('#zip').val();
   $('#safeAjax').safeDBMS(dataItems,function(result){ 
      $('#savedStatus').html('['+(result.safeAjax)?'saved ok':'save failed'+']');
   });
});

}}}

=== Server-side Usage ===

This plugin requires a server-based connector (provided as part of this package, implemented in PHP) which manages the connections to and interactions with the database. This connector is where you will select the level of protection desired from a set of two options: Simple and Advanced.  

The two levels of protection are provided in a class hierarchy instatiate whichever one you want and the usage is identical -- Low security: single username/password verification for all resources (no database table of usernames and passwords required.)  Or High security: database based multipleUser+accessLevel configuration which allows for different logins to have different powers (the create statment is commented into the code so that you can generate the required table yourself).

I have a set of helper functions I use to access/manipulate data in ways that are protected against sql-injection attacks, feel free to use them however you wish.

*A word on parameters, I use a single JSON object to handle everything.  period.  full-stop.*

I long ago settled on using properties lists (maps/hashes/associativeArrays) to encapsulate all parameters sent to and received from routines.  While a little bit of predictability and perhaps some type-safety was lost the overall increase in ease-of-use far outweighed the required increase in stack memory.  When it came time to implement safeAjax there was no second thought -- I think you will enjoy it as much as I do.

On the request side I merge the _GET and _POST parameter arrays into one $params [associative] array so that you don't have to care how the values were sent.

For the return I provide a variable $json into which everything to be returned is to be put.  The authorization routines will fill the safeAjax and safeAjaxRequires values and you should load up the rest with your outputs.  The [provided] connector will encode the $json variable at the completion of the request and the web-side plugin will parse it back into a variable ready for your usage.

*A word on code organization, segregate and compartmentalize wherever possible !!*

This plugin was written to support a new drop-in methodology for easily extending the server-side codebase using a predefined interface which your classes must implement.  You then populate a particular directory with your class files and every request/response that goes thru the connector is given to each class to see if they want to do something with the request.   

This support for drop-in classes allows one to easily group sets of routines related to particular actions or entities.  It's far easier to compartmentalize your code and limit the ripples of change and testing when you can segment your codebase in this way.  Even though all code is instatiated for each request and response whether it will be used or not I believe the tradeoff to code stability and maintainablity to be completely worth the cost of a few more milliseconds per request/response cycle.



=== Changelog ===

<pre>
see allen @joslin .net for changes
08/06/09 - version 2.3: finished dropin-class support, cleaned, packaged
07/01/09 - version 2.2: extract html to dialogs.html
06/14/09 - version 2.1: modifications to support IE 
05/20/09 - version 2.0: rewrite/refactor, encapsulate connector, return JSON structure 
03/08/09 - version 1.0, code collection from dev/test/debug 
</pre>