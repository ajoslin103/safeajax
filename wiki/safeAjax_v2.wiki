#labels ajoslin,ajax,security,jquery,plugin,php,password,session,cookie
General information about the safeAjax plugin by Allen Joslin

=== In Summary ===

Ajax is a thing of beauty, combining Ajax and jQuery creates elegance -- an insideous elegance resulting in a need for truly seamless protection, protection that is offered via safeAjax.

I wrote this plugin to password protect my own web pages/sites and also to safeguard my backend resources and actions. It's originally based upon Chris Shifletts article: the truth about sessions, and uses the cross-platform JSON notation for communications between the javascript and the server-side code.  I now offer it up to you, Enjoy !!

=== Web-side Usage === 

At this time there are several plugins that safeAjax depends upon, the next version will load them automatically -- for now you have to include them yourself 

{{{
<script type='text/javascript'     src='http://code.jquery.com/jquery-latest.pack.js'></script>
<script type='text/javascript'     src='http://www.json.org/json2.js'></script>
<link type='text/css' media='all' href='http://dev.iceburg.net/jquery/jqModal/jqModal.css' rel='stylesheet' />
<script type='text/javascript'     src='http://dev.iceburg.net/jquery/jqModal/jqModal.js'></script>
<script type='text/javascript'     src='http://plugins.jquery.com/files/jquery.sha1.js.txt'></script>
<script type='text/javascript'     src='http://plugins.jquery.com/files/jquery.query-2.1.5.js.txt'></script>
}}}

Include safeAjax and identify the connector when your page loads

{{{
<script type='text/javascript'      src='./lib/safeAjax/jquery.safeAjax_v2.js'></script>
<script type='text/javascript'>
$(document).ready(function() {
   $('#safeAjax').safeAjax({ ajaxConnector: './lib/safeAjax/dbConnector.php' });
});
</script>
}}}

Note: you will have to add a safeAjax div somewhere in your document, nothing will work without it! (note that safeAjax uses console logging for errors and progress info.)

{{{
<div id='safeAjax'></div>
}}}

* Lights, Camera, Action ! *

Use the connector at will to request info and actions from the backend, should your backend deem that a particular resource/action needs protection then safeAjax will enforce the protection automatically.  

The jqModal plugin will be used to present a login dialog which will not go away until the backend accepts the given username and password combination, and cookies the user's browser (the cookie does not contain any info that can be used to authorize any other browser or session and has a configurable expiry date.)

Once the user succeeds then the request will be re-submitted and approved using the previously deposited cookie.  The request/response that caused the login to be required is discarded and a copy is automatically re-submitted by safeAjax to streamline the process of approving requests as well as [slightly] improving the overall security.

* jQuery samples * 

{{{

// for our purposes, the backend allows this
$('#safeAjax').safeDBMS({ load: 'address', id: addrId },function(data){ 
   $('#addr').val(data.addr);    $('#city').val(data.city);
   $('#state').val(data.state);  $('#zip').val(data.zip);
});

// for our purposes, the backend restricts this
$('#saveBtn').click(function(){
   dataItems = { save: 'address', id: addrId };
   dataItems.addr = $('#addr').val();    dataItems.city = $('#city').val();
   dataItems.state = $('#state').val();  dataItems.zip =$('#zip').val();
   $('#safeAjax').safeDBMS(dataItems,function(result){ 
      $('#savedStatus').html('['+(result.sqlResult)?'saved ok':'save failed'+']');
   });
});

}}}

=== Server-side Usage ===

This plugin requires a server-based connector (provided as part of this package, implemented in PHP) which manages the connections to and interactions with the database. This connector is where you will select the level of protection desired from a set of two options: Simple and Advanced.  

The two levels of protection are provided in a class hierarchy instatiate whichever one you want and the usage is identical -- Low security: single username/password verification for all resources (no database table of usernames and passwords required.)  Or High security: database based multipleUser+accessLevel configuration which allows for different logins to have different powers (a sql create statement is commented into the code so that you can generate the required table yourself).

I have a set of helper functions I use to access/manipulate data in ways that are protected against sql-injection attacks, feel free to use them however you wish.

*A word on parameters, I use a single JSON object to handle everything.  period.  full-stop.*

I long ago settled on using properties lists (maps/hashes/associativeArrays) to encapsulate all parameters sent to and received from routines.  While a little bit of predictability and perhaps some type-safety was lost the overall increase in ease-of-use far outweighed the required increase in stack memory.  When it came time to implement safeAjax there was no second thought -- I think you will enjoy it as much as I do.

On the request side I merge the _GET and _POST parameter arrays into one $params [associative] array so that you don't have to care how the values were sent.

For the return I provide a variable $json into which everything to be returned is to be put.  The authorization routines will fill the safeAjax and safeAjaxRequires values and you should load up the rest with your outputs.  The [provided] connector will encode the $json variable at the completion of the request and the web-side plugin will parse it back into a variable ready for your usage.

*A word on code organization, segregate and compartmentalize wherever possible !!*

This plugin was written to support a new drop-in methodology for easily extending the server-side codebase using a predefined interface which your classes must implement.  You then populate a particular directory with your class files and every request/response that goes thru the connector is given to each class to see if they want to do something with the request.   

This support for drop-in classes allows one to easily group sets of routines related to particular actions or entities.  It's far easier to compartmentalize your code and limit the ripples of change and testing when you can segment your codebase in this way.  Even though all code is instatiated for each request and response whether it will be used or not I believe the tradeoff to code stability and maintainablity to be completely worth the cost of a few more milliseconds per request/response cycle.

The current implementation looks for the drop-ins folder as a sibling to the folder where safeAjax was loaded from -- you can change this (carefully) to wherever you wish.  Note: there is a required naming convention for these files -- do not fail to name your files properly! <pre> <className>.class.php </pre> Only files matching this naming convention will be loaded and executed !!

Here's a sample server side class file to handle the address load and save functions we referenced above:

{{{
<?

require_once("../safeAjaxDBMS/safeAjax_DBMS.interface.php");

// This is a sample usage of the interface for database access classes, this file would be named Addresses.class.php

class Addresses implements safeAjax_DBMS {

   function handleRequest ( &$params, &$json, &$dbmsConnector, &$reader, &$writer ) {
   
      // &$params -- this associative array contains all the _GET and _POST parameters 
      // &$json -- this associative array is provided for your return values
      // &$dbmsConnector -- this variable implements the security codebase and confirms username/passwords
      // &$reader -- this variable holds the readOnly connection to the database
      // &$writer -- this variable holds the readWite connection to the database

      if ($reader != null) {
         if ($params['load'] == 'address') { 
            if ($dbmsConnector->testAccessLevel(0,$json,$reader)) { // still required, although level 0 needs no authentication
               $address_id = mysql_real_escape_string($params['id'],$reader->conn($json)); 
               $selectSQL = " select addr, city, state, zip from tbl_address_records where id = $tbl_address_records ";
               if ($selectResult = $reader->db_select_json($selectSQL,$json)) {
                  if ($thisRow = mysql_fetch_assoc($selectResult)) {
                     foreach (array_keys($thisRow) as $colName) { 
                        $json[$colName] = $thisRow[$colName];
                     }
                  }
               }
            }
         }
      }

      if ($writer != null) {
         if ($params['save'] == 'address') { 
            if ($dbmsConnector->testAccessLevel(5,$json,$reader)) { // required, anything above level 0 should require some authentication
               $address_id = mysql_real_escape_string($params['id'],$reader->conn($json)); 
               $addr = mysql_real_escape_string($params['name'],$writer->conn($json));
               $city = mysql_real_escape_string($params['city'],$writer->conn($json));
               $state = mysql_real_escape_string($params['state'],$writer->conn($json));
               $zip = mysql_real_escape_string($params['zip'],$writer->conn($json));
               $updateSQL = " update tbl_address_records set addr='$addr', city='$city', state='$state', zip='$zip' where id = $tbl_address_records";
               if ($writer->db_update_json($updateSQL,$json)) {
                  $json['sqlResult'] = true;
               }
            }
         }
      }

   }

}

?>
}}}

=== Changelog ===

<pre>
see allen @joslin .net for changes
08/06/09 - version 2.3: finished dropin-class support, cleaned, packaged
07/01/09 - version 2.2: extract html to dialogs.html
06/14/09 - version 2.1: modifications to support IE 
05/20/09 - version 2.0: rewrite/refactor, encapsulate connector, return JSON structure 
03/08/09 - version 1.0, code collection from dev/test/debug 
</pre>